![공간 복잡도 배경 이미지](/assets/images/space-complexity.jpg)
<strong>공간 복잡도(Space Complexity)</strong>란 알고리즘이 실행될 때 **얼마나 많은 메모리를 사용하는지를 측정하는 지표**이다. 이를 통해 알고리즘이 얼마나 효율적으로 메모리를 활용하는지 평가할 수 있다.

### 공간 복잡도(Space Complexity) 구성 요소

공간 복잡도(Space Complexity)는 프로그램 실행 중 사용되는 메모리를 기반으로 두 가지로 나눌 수 있다.

1. 알고리즘과 무관한 공간 → 고정 공간(Fixed Space)

- 알고리즘과 상관없이 실행 시 항상 고정적으로 필요한 공간
- 예시
  - 코드 영역: 코드 자체가 차지하는 공간
  - 시스템 메모리: 실행 환경에서 필요한 공간
  - 전역 변수: 상수와 같은 고정 변수들이 사용하는 공간

2. 알고리즘과 밀접한 공간 → 가변 공간(Variable Space)

- 알고리즘이 실행되며 입력 크기나 실행 방식에 따라 동적으로 변하는 공간
- 예시
  - 입력 데이터를 저장하는 공간
  - 임시 변수, 배열 등 알고리즘 실행을 위해 생성되는 공간
  - 재귀 호출 시 사용되는 재귀 스택(Recursion Stack)

### 공간 복잡도(Space Complexity) 표현

공간 복잡도도 시간 복잡도와 마찬가지로 점근적 표기법을 사용한다. 일반적으로 $O(1)$, $O(n)$ 등으로 나타내며, 알고리즘의 메모리 사용량이 입력 크기 $n$에 따라 어떻게 증가하는지 설명한다.

### 공간 복잡도(Space Complexity) 계산 방법

1. 고정 공간(Fixed Space)

- $O(1)$: 입력 크기와 상관없이 일정한 공간만 사용하는 경우

2. 가변 공간(Variable Space)

- 알고리즘이 필요로 하는 추가 메모리 공간으로, 보통 입력 크기 $n$에 따라 달라진다.
- 반복문을 사용하는 경우 배열 등의 크기가 $n$에 비례하여 증가하면 공간 복잡도는 $O(n)$이다.
- 재귀 호출의 경우, 호출 깊이에 따라 공간 복잡도가 $O(n)$ 또는 $O(log n)$으로 증가할 수 있다.

### 대표적인 공간 복잡도

- $O(1)$ : 상수 공간 (추가 공간이 거의 필요하지 않음) - <i style='color: #6e6e6e'>단순 변수 사용, 입력 데이터가 고정 크기인 경우</i>
- $O(n)$ :
- $O(n^{2})$ :

<!-- ### 시간 복잡도(Time Complexity) 표현 방법

시간 복잡도는 주로 점근적 표기법을 사용하여 나타내며, 다음 3가지로 구분된다.

1. 오메가 표기법(_Big-Ω Notation_): 최상의 경우

   - 알고리즘이 가장 효율적으로 작동할 때의 복잡도를 나타낸다.

2. 세타 표기법(_Big-Θ Notation_): 평균의 경우

   - 알고리즘의 평균적인 성능을 나타낸다.

3. 빅오 표기법(_Big-O Notation_): 최악의 경우
   - 알고리즘이 가장 비효율적으로 작동할 때의 복잡도를 나타내며, 주로 사용된다.
   - 최악의 상황을 기준으로 성능을 예측하여 안정적인 알고리즘 선택에 도움을 준다.

### 시간 복잡도(Time Complexity)를 평가하는 이유

시간 복잡도(Time Complexity)를 분석하는 것은 알고리즘의 성능을 비교하고, 더 큰 입력에서도 효율적으로 작동할 수 있는지를 판단하기 위함이다. 이를 통해 최적의 알고리즘을 선택하여 프로그램의 성능을 극대화할 수 있다.

## Big-O Notation

![Big-O 표기법 차트](/assets/images/big-o_notation_chart.png)

빅오(Big-O) 표기법은 입력 크기 N에 따라 알고리즘의 성능을 나타내는 방법으로, 가장 느린 실행 시간의 상한선을 제공한다. 알고리즘의 실행 시간이 입력 크기에 따라 얼마나 빨리 증가하는지 설명한다.

### 대표적인 Big-O 표기법 종류

- $O(1)$: 상수 시간 (입력 크기에 상관없이 일정한 실행 시간)
- $O(logn)$: 로그 시간 (입력이 증가해도 비교적 느리게 증가)
- $O(n)$: 선형 시간 (입력 크기에 비례)
- $O(nlogn)$: 선형 로그 시간 (일반적인 효율적인 정렬 알고리즘)
- $O(n^{2})$: 이차 시간 (N \* N 시간)
- $O(2^{n})$: 지수 시간 (입력이 증가할수록 실행 시간이 매우 빠르게 증가)
- $O(n!)$: 팩토리얼 시간 (모든 경우의 수를 계산) -->
