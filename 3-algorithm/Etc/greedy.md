그리디(Greedy) 알고리즘은 **매 순간 최적이라고 판단되는 선택을 반복하여 전체 문제의 근사 해를 구하는 알고리즘**이다.

#### 그리디(Greedy) 알고리즘 특징

- **지역적으로 최적인 선택(Local Optimal Choice)을 반복**하여 **전역적인 최적해(Global Optimal Choice)를 찾으려는 전략을 사용**한다.
- 현재 상태에서 최선이라고 판단되는 해를 선택하며, **선택 이후에는 이전의 선택을 고려하지 않는다.**
- **일부 문제**에서는 최적해를 구할 수 있지만, **항상 최적해를 보장하지는 않는다.**
- 문제를 해결하기 위한 **탐색 범위를 줄이고 빠른 계산이 가능하므로 시간 복잡도가 상대적으로 낮은 경우가 많다.**
- 그리디 알고리즘은 현재 상태에서 최선이라고 판단되는 해를 선택하면 되기 때문에 특정 구현 방식이 존재하는 것이 아닌 **하나의 개념**으로 봐야한다.

#### 그리디(Greedy) 알고리즘 한계점

- 그리디 알고리즘은 항상 최적해를 보장하지 않는다.
  - 마시멜로 문제:
    - 아이가 지금 당장 마시멜로 1개를 먹지 않으면, 10분 뒤에 마시멜로 2개를 먹을 수 있다.
    - 그러나, 그리디 알고리즘은 당장의 최적인 선택을 고르므로, 전체 최적해를 놓칠 수 있다. <br />
- **반례가 존재하는 문제에서는 사용하기 어렵다.**
- 미래의 선택이 현재의 선택에 의해 제한될 경우, 최적해를 찾기 어려울 수 있다.

<br />

## 그리디(Greedy) 알고리즘 예시

### 예시 1. 그래프 최소 비용 계산

![그리디 알고리즘 예시 1](/assets/images/algorithm/etc/greedy/greedy_example_1.webp)

> 문제: A 정점에서 F 정점까지 최단 경로를 구하여라

1. A 정점에서 이동 가능한 B, D 정점 중에 현재 가장 짧은 거리인 B 정점으로 이동한다.
2. B 정점에서 이동 가능한 C 정점으로 이동한다.
3. C 정점에서 이동 가능한 F 정점으로 이동한다.
4. A 정점에서 F 정점까지 총 65km 거리로 도착했다.
   - 하지만, A → D → E → F 순으로 이동하면 33km 거리를 도착할 수 있다.
   - 즉, 해당 문제에서 전체의 최적해가 아닌 근사 해를 구하게 된다.

### 예시 2. 최소 거스름돈 문제

![그리디 알고리즘 예시 2](/assets/images/algorithm/etc/greedy/greedy_example_2.webp)

> 문제 : 값을 지불 하고 최소로 받을 수 있는 거스름돈을 구하여라

1. `[50000, 10000, 5000, 1000, 500, 100, 50, 10]` 중 가장 금액이 큰 단위부터 거슬러준다.
2. 가장 직관적인 그리디 문제
