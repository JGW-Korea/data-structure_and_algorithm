![다이나믹 프로그래밍](/assets/images/algorithm/etc/dynamic_programming/dp.png)

다이나믹 프로그래밍(DP, Dynamic Programming) 알고리즘은 **주어진 문제를 작은 부분 문제로 나누고, 각 부분 문제의 결과를 저장하여 중복 계산을 피함으로써 효율적으로 해결하는 최적화 기법**이다.

#### 다이나믹 프로그래밍(Dynamic Programming) 특징

- 다이나믹 프로그래밍은 특정한 구현 방식이 정해져 있는 것이 아니라, **부분 문제의 결과를 저장하여 중복 계산을 피하는 방식으로 문제를 해결하는 기법**이다.
- **메모리를 비교적 많이 사용**하지만, **대부분의 경우 $O(N)$ 이하의 시간 복잡도로 빠른 성능을 제공**한다.
- 다이나믹 프로그래밍은 **메모이제이션(Memoization)과 타뷸레이션(Tabulation) 두 가지 방식으로 구현**할 수 있다.

<br />

## 메모이제이션과 타뷸레이션

### I. 메모이제이션(Memoization) - 상향식 접근법(Top-Down)

```javascript
function fibonnaci(n, memo = {}) {
  if (n in memo) return memo[n]; // 이미 계산된 값이 있으면 반환
  if (n <= 1) return n;

  // 재귀 호출 후 저장
  memo[n] = fibonnaci(n - 1, memo) + fibonnaci(n - 2, memo);
  return memo[n];
}
```

- 메모이제이션 기법은 **재귀 함수(Recursion Function)**와 **캐시(Cache)를 활용하여 구현**한다.
- 이 기법은 큰 문제를 해결하기 위해 필요한 작은 문제들을 필요할 때만 재귀 호출로 해결하고, 그 결과를 저장하여 동일한 연산을 반복하지 않도록 한다.
- 또한, 콜 스택(Call Stack)을 사용하므로, 자연스럽게 큰 문제에서 작은 문제로 내려가며 해결하는 방식을 따른다.
- 큰 문제를 해결하는 과정에서 부분 문제(Sub-problems)의 결과를 저장하여, 동일한 부분 문제가 다시 발생했을 때 불필요한 연산을 피하고 저장된 값을 재사용함(메모이제이션)으로써 성능을 최적화한다.

### II. 타뷸레이션(Tabulation) - 하향식 접근법(Bottom-Up)

```javascript
function fibonnaci(N) {
  const dp = new Array(N + 1).fill(0);

  dp[1] = 1;
  dp[2] = 2;

  for (let i = 3; i <= N; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }

  return dp[N];
}
```

- 타뷸레이션 기법은 **반복문(Iteration)과 테이블(Table)를 활용하여 구현**한다.
- 이 기법은 **작은 문제부터 차례대로 해결**하며, **이를 활용해 점진적으로 큰 문제를 해결하는 방식**이다.
- 또한, **반복문을 사용하여 작은 값부터 차례로 계산하여 최종 값을 도출**한다.
- **문제를 부분 문제(Sub-Problems)로 나눈 뒤, 작은 문제부터 순차적으로 해결하며 결과를 테이블(Table)에 저장하는 방식**을 따른다.
- 이렇게 **저장된 테이블을 기반으로 큰 문제를 단계적으로 구축하여 최종 해답을 도출**한다.

### III. 메모이제이션(Memoization) vs 타뷸레이션(Tabulation) 비교

#### 공통점

- 두 방식 모두 문제를 **부분 문제(Sub-Problems)로 나누고, 결과를 저장하여 재사용함으로써 계산 효율성을 높인다.**

#### 속도 및 메모리 차이

1. **_메모이제이션(Memoization)_**

   - 필요한 부분 문제만 해결하므로 **메모리 사용이 더 효율적**이다.
   - 그러나, **재귀 호출의 오버헤드로 인해 속도는 타뷸레이션보다 느릴 수 있다.**

2. **타뷸레이션(Tabulation)**

   - 모든 부분 문제를 미리 해결하기 때문에 **메모리 사용량 더 많다.**
   - 하지만, **반복문을 통해 순차적으로 해결하므로 속도 면에서는 메모이제이션보다 빠르다.**

<br />

## 재귀와 다이나믹 프로그래밍(Dynamic Programming) 차이점

![재귀와 DP](/assets/images/algorithm/etc/dynamic_programming/dp_different.webp)

### I. 피보나치 수열 - 재귀 구현

```javascript
function fibonnaci(N) {
  if (N <= 1) return 1;
  return fibonnaci(N - 1) + fibonnaci(N - 2);
}
```

- 피보나치 수열을 재귀 함수로 구현하면 중복 연산이 많아져 **시간 복잡도가 지수적으로 증가**한다.
- 이에 따라 **N이 커질수록 연산량이 급격히 증가**하며, N이 25 이상일 경우 실행 속도가 느려지고, 심할 경우 스택 오버플로우(Stack Overflow)가 발생할 수 있다.

### II. 피보나치 수열 - DP 구현

```javascript
function fibonnaci(N) {
  const dp = new Array(N + 1).fill(0);

  dp[1] = 1;
  dp[2] = 2;

  for (let i = 3; i <= N; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }

  return dp[N];
}
```

- 피보나치 수열을 다이나믹 프로그래밍으로 구현하면 **중복 연산을 방지**할 수 있으며, **이전에 계산된 값을 저장하여 재사용**할 수 있다.
- 이를 통해 **시간 복잡도를 대부분 $O(N)$으로 최적화**할 수 있다.
- 또한, 이미 **저장된 값을 가져오는 연산은 $O(1)$의 시간 복잡도**를 가진다.

<br />

## 코딩 테스트 - 다이나믹 프로그래밍(Dynamic Programming) 접근 방법

> 다이나믹 프로그래밍 유형은 키워드만으로 동적 계획법 문제임을 알기 어렵다.

#### 다이나믹 프로그래밍 조건

1. 가장 작은 문제를 정의할 수 있는가?
2. 작은 문제를 통해 큰 문제를 해결할 수 있는 규칙이 있는가?

#### 다이나믹 프로그래밍 참고사항

- 간혹 메모리를 너무 사용하여 메모리 초과로 인해 문제를 통과 못하는 경우도 존재한다.
- 이런 경우에는 백트래킹 알고리즘을 이용할 수 있지만, 보통 코딩 테스트에서는 자주 출제되지는 않는다.

<br />

### 다이나믹 프로그래밍(Dynamic Programming) 문제 풀이 과정

1. **DP 테이블을 정의**한다.

   - DP 테이블을 정의하는 이유는 중복된 부분 문제의 결과를 저장하는 데 사용되는 데이터 구조이다.
   - DP 테이블의 크기와 형태는 문제의 특성에 따라 달라진다.
   - 예를 들어, 피보나치 수열에서는 1차원 배열이 될 수 있지만, 배낭 문제와 같은 경우는 2차원 배열이 될 수도 있다.

2. 문제에서 요구하는 **점화식을 정의**한다.

   - 점화식은 부분 문제들 간의 관계를 나타내는 식이다.
   - 점화식을 통해 큰 문제를 작은 부분 문제로 나누고, 이 부분 문제들의 해결책을 이용하여 전체 문제를 해결할 수 있다.
   - 점화식을 찾는 것은 다이나믹 프로그래밍 문제를 풀이하는 데 있어서 가장 중요한 단계다.

3. 점화식에 따라 **DP 테이블의 초기값을 정의**한다.

   - 초기값은 가장 작은 부분 문제의 해결책을 의미한다.
   - 초기값을 설정함으로써 DP 테이블을 채워 나가는 과정을 시작할 수 있다.
   - 초기값은 문제의 특성에 따라 달라진다.
