![다이나믹 프로그래밍](/assets/images/algorithm/etc/dynamic_programming/dp.png)

다이나믹 프로그래밍(DP, Dynamic Programming) 알고리즘은 주어진 문제를 작은 부분 문제로 나누고, 각 부분 문제의 결과를 저장하여 중복 계산을 피함으로써 효율적으로 해결하는 최적화 기법이다.

#### 다이나믹 프로그래밍(Dynamic Programming) 특징

- 다이나믹 프로그래밍은 특정한 구현 방식이 정해져 있는 것이 아니라, 부분 문제의 결과를 저장하여 중복 계산을 피하는 방식으로 문제를 해결하는 기법이다.
- 메모리를 비교적 많이 사용하지만, 대부분의 경우 $O(N)$ 이하의 시간 복잡도로 빠른 성능을 제공한다.
- 다이나믹 프로그래밍은 메모이제이션(Memoization)과 타뷸레이션(Tabulation) 두 가지 방식으로 구현할 수 있다.

<br />

## 메모이제이션과 타뷸레이션

### 메모이제이션(Memoization) - 상향식 접근법(Top-Down)

```javascript
function fibonnaci(n, memo = {}) {
  if (n in memo) return memo[n]; // 이미 계산된 값이 있으면 반환
  if (n <= 1) return n;

  // 재귀 호출 후 저장
  memo[n] = fibonnaci(n - 1, memo) + fibonnaci(n - 2, memo);
  return memo[n];
}
```

- 메모이제이션 기법은 재귀 함수(Recursion Function)와 캐시(Cache)를 활용하여 구현한다.
- 이 기법은 큰 문제를 해결하기 위해 필요한 작은 문제들을 필요할 때만 재귀 호출로 해결하고, 그 결과를 저장하여 동일한 연산을 반복하지 않도록 한다.
- 또한, 콜 스택(Call Stack)을 사용하므로, 자연스럽게 큰 문제에서 작은 문제로 내려가며 해결하는 방식을 따른다.
- 큰 문제를 해결하는 과정에서 부분 문제(Sub-problems)의 결과를 저장하여, 동일한 부분 문제가 다시 발생했을 때 불필요한 연산을 피하고 저장된 값을 재사용함(메모이제이션)으로써 성능을 최적화한다.

### 타뷸레이션(Tabulation) - 하향식 접근법(Bottom-Up)

```javascript
function fibonnaci(N) {
  const dp = new Array(N + 1).fill(0);

  dp[1] = 1;
  dp[2] = 2;

  for (let i = 3; i <= N; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
  }

  return dp[N];
}
```

- 타뷸레이션 기법은 반복문(Iteration)과 캐시(Cache)를 활용하여 구현한다.
- 이 기법은 작은 문제부터 차례대로 해결하며, 이를 활용해 점진적으로 큰 문제를 해결하는 방식이다.
- 또한, 반복문을 사용하여 작은 값부터 차례로 계산하여 최종 값을 도출한다.
- 문제를 부분 문제(Sub-Problems)로 나눈 뒤, 작은 문제부터 순차적으로 해결하며 결과를 테이블(Table)에 저장하는 방식을 따른다.
- 이렇게 저장된 테이블을 기반으로 큰 문제를 단계적으로 구축하여 최종 해답을 도출한다.

### 메모이제이션(Memoization) vs 타뷸레이션(Tabulation) 비교

#### 공통점

- 두 방식 모두 문제를 부분 문제(Sub-Problems)로 나누고, 결과를 저장하여 재사용함으로써 계산 효율성을 높인다.

#### 속도 및 메모리 차이

1. 메모이제이션(Memoization)

   - 필요한 부분 문제만 해결하므로 메모리 사용이 더 효율적이다.
   - 그러나, 재귀 호출의 오버헤드로 인해 속도는 타뷸레이션보다 느릴 수 있다.

2. 타뷸레이션(Tabulation)

   - 모든 부분 문제를 미리 해결하기 때문에 메모리 사용량 더 많다.
   - 하지만, 반복문을 통해 순차적으로 해결하므로 속도 면에서는 메모이제이션보다 빠르다.
