### I. 신장 트리(Spanning Tree)

![신장 트리](/assets/images/algorithm/graph/mst_spanning_tree.webp)

신장 트리(Spanning Tree)는 무방향 그래프의 부분 그래프(Sub Graph) 중에서 모든 정점을 포함하면서 트리의 성질을 만족하는 그래프를 의미한다.

#### 부분 그래프(Sub Graph)

- 무방향 그래프에서 일부 정점과 간선만을 선택하여 구성한 새로운 그래프를 의미한다.

#### 신장 트리(Spanning Tree) 특징

- 모든 정점을 포함하는 부분 그래프이다.
- 트리의 성질을 만족해야 한다.
  1. 트리는 무방향이면서 사이클이 존재하지 않는 연결 그래프이다. _(연결 그래프: 특정 정점에서 모든 정점으로 이동 가능한 그래프)_
  2. 그래프의 정점 개수가 V개일 때, 신장 트리는 정확히 V - 1개의 간선을 가진다.

<br />

### II. 최소 신장 트리(MST, Minimum Spanning Tree)

![최소 신장 트리](/assets/images/algorithm/graph/mst.webp)

최소 신장 트리(MST, Minimum Spanning Tree)는 신장 트리 중에서 간선의 가중치 합이 최소가 되는 트리를 의미한다.

#### 최소 신장 트리(MST, Minimum Spanning Tree) 특징

- 최소 신장 트리는 주어진 그래프에서 여러 개의 최소 신장 트리가 만들어질 수 있다.
- 최소 신장 트리 알고리즘 종류
  1. 크루스칼(Kruskal) 알고리즘
  2. 프림(Prim) 알고리즘

<br />

### III. 크루스칼(Kruskal) 알고리즘

크루스칼(Kruskal) 알고리즘은 그리디 알고리즘과 [유니온-파인드(Union-Find)](./union-find.md) 알고리즘을 활용하여 그래프의 최소 신장 트리를 구하는 알고리즘이다.

#### 크루스칼(Kruskal) 알고리즘 동작 과정

1. 간선 정렬: 그래프의 모든 간선을 가중치 기준 오름차순으로 정렬한다. _(그리디(Greedy) 알고리즘)_
2. 초기화: 모든 정점을 개별적인 집합(부분 집합)으로 만든다. _(유니온-파인드(Union-Find) 알고리즘)_
3. 간선 선택 및 연결

   - 정렬된 간선 목록에서 가중치가 가장 낮은 간선부터 하나씩 선택한다.
   - 선택한 두 정점이 서로 다른 집합에 속해 있다면, 해당 간선을 최소 신장 트리에 추가하고 두 집합을 합친다.

4. 사이클 방지 _(유니온-파인드(Union-Find) 알고리즘)_

   - 두 정점이 이미 같은 집합에 속해 있다면 해당 간선은 선택하지 않는다. _(같은 집합일 경우 사이클 발생)_
   - 최상위 부모(루트 노드)를 비교하여 같은 집합인지 확인하고, 다른 집합이면 합친다.

5. 모든 정점이 하나의 집합으로 연결될 때까지 반복
   - 최소 신장 트리를 형성할 때까지 위의 과정을 반복한다.
   - 간선 개수가 $(정점 개수 - 1)$에 도달하면 알고리즘을 종료한다.

<br />

### 크루스칼(Kruskal) 알고리즘 동작 과정 원리 설명

![최소 신장 트리](/assets/images/algorithm/graph/mst_kruskal_works.webp)

> 크루스칼 알고리즘을 사용하기 전에 가중치 값이 가장 낮은 정점을 선택하기 위해 간선을 오름차순 정렬 후 실행한다.

1. 간선의 가중치 값이 가장 낮은 A-D 간선을 선택 후, 두 정점을 하나의 집합으로 구성한다.
2. 다음으로 간선의 가중치 값이 가장 낮은 A-B 간선을 선택 후, 두 정점을 하나의 집합으로 구성한다.
3. 다음으로 간선의 가중치 값이 가장 낮은 B-C 간선을 선택 후, 두 정점을 하나의 집합으로 구성한다.
4. 다음으로 간선의 가중치 값이 가장 낮은 B-F 간선을 선택 후, 두 정점을 하나의 집합으로 구성한다.
5. 다음으로 간선의 가중치 값이 가장 낮은 A-C 간선을 선택한다.

   - 하지만, A-C 간선을 하나의 집합으로 구성하게 되면, A → B → C 구간에서 사이클(Cycle)이 발생한다.
   - 그렇기 때문에, A 정점과 C 정점의 최상위 원소가 같은 원소로 이미 같은 집합에 속하기 때문에, 해당 간선은 넘어간다.

6. 다음으로 간선의 가중치 값이 가장 낮은 F-G 간선을 선택하고, 두 정점을 하나의 집합으로 구성한다.
7. 다음으로 간선의 가중치 값이 가장 낮은 D-E 간선을 선택하고, 두 정점을 하나의 집합으로 구성한다. _(7번 과정까지 진행을 하게 되면, 최소 신장 트리 조건에 부합)_

8. 다음으로 간선의 가중치 값이 가장 낮은 E-F 간선을 선택하지만, 사이클이 발생하기 때문에 넘어간다.
9. 다음으로 간선의 가중치 값이 가장 낮은 C-F 간선을 선택하지만, 사이클이 발생하기 때문에 넘어간다.
10. 모든 간선을 하나의 연결 그래프로 구성이 되어 최소 신장 트리가 완성됨

#### 크루스칼 알고리즘 코드 구조([백준 1197. 최소 스패닝 트리](https://www.acmicpc.net/problem/1197))

```javascript
// 파인드(find) 연산: 특정 정점의 대표 정점을 찾기 위한 연산
function find(parent, x) {
  if (parent[x] === x) {
    return x;
  }

  // 경로 압축 최적화: 대표 정점을 찾기 위한 경로에 있는 모든 원소들이 직접 최상위 부모를 가리키도록 변경
  return (parent[x] = find(parent, parent[x]));
}
// 유니온(Union) 연산: 두 개의 서로서 집합을 하나의 집합으로 병합
function union(parent, a, b) {
  a = find(parent, a);
  b = find(parent, b);

  // 더 작은 값을 기준으로 서로서 집합을 하나의 집합으로 병합한다.
  if (a < b) {
    parent[b] = a;
  } else {
    parent[a] = b;
  }
}

// 두 집합이 동일한 대표 루트를 가리키고 있는지 확인
function compare(parent, a, b) {
  a = find(parent, a);
  b = find(parent, b);

  // 같은 집합일 경우 사이클이 발생할 수 있음
  return a === b;
}

function solution(V, graph) {
  let parent = new Array(V + 1); // 유니온 연산에 필요한 1차원 배열 정의 + 초기화는 자기 자신을 부모로 지정
  let answer = 0;

  // 그래프의 간선을 가중치 값을 기준으로 정렬
  graph.sort((a, b) => a[2] - b[2]);

  for (const [a, b, cost] of graph) {
    if (!compare(a, b)) {
      answer += cost;
      union(parent, a, b);
    }
  }

  return answer;
}
```
