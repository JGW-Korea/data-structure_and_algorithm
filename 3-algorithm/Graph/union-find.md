![유니온-파인드](/assets/images/algorithm/graph/union-find.png)

유니온-파인드(Union-Find) 알고리즘은 **서로서 집합(Disjoint Set)을 효율적으로 관리하기 위한 알고리즘**이다.

- **서로서 집합(Disjoint Set)**이란, **공통 원소를 가지지 않는 두 개 이상의 집합을 의미**한다.
- 유니온-파인드 알고리즘은 그래프에서 **사이클 판별**, **같은 그룹에 속하는 노드 판별**, **최소 신장 트리 구성(MST)** 등 **다양한 문제에서 활용**된다.

#### 유니온-파인드(Union-Find) 연산

- **유니온(Union) 연산**: 두 개의 서로서 집합을 **하나의 집합으로 병합**하는 연산이다.
- **파인드(Find) 연산**: 특정 원소가 속한 집합의 **대표(Root) 원소를 찾는 연산**이다.
- **유니온(Union)과 파인드(Find) 연산을 조합**하여, 원소들이 **같은 집합에 속해 있는지를 판별**하고 **필요한 경우 병합**함으로써 **집합을 효율적으로 관리**할 수 있다.

#### 유니온-파인드(Union-Find) 특징

- **트리 구조 기반:**

  - 유니온-파인드 알고리즘은 **결과적으로 트리 형태로 구성**된다.
  - **각 노드는 자신의 부모 노드를 가리키며**, **같은 집합에 속한 노드들은 공통된 최상위 노드(Root Node)를 공유**한다.

- **재귀 함수를 이용한 구현:**
  - 파인드(Find) 연산은 보통 **재귀 함수를 사용하여 구현**하는 경우가 많다.
  - 하지만, 트리가 한쪽으로 치우친 **편향 트리(Skewed Tree)가 되면 성능이 저하**될 수 있다.
  - 이를 방지하기 위해 **경로 압축(Path Compression) 등의 최적화 기법을 적용**하여 **시간 복잡도를 개선**할 수 있다.

<br />

### 유니온(Union) 연산: 두 개의 서로서 집합을 하나의 집합으로 병합

![유니온 연산](/assets/images/algorithm/graph/union-find_union.webp)

유니온(Union) 연산은 **서로서 집합(Disjoint Set)을 관리하는 대표적인 연산**으로, **특정 원소들이 속한 집합을 하나로 합치는 과정**이다. 이를 **1차원 배열을 이용해 표현**할 수 있다.

#### 유니온(Union) 연산 특징

- **union[index]**: **원소의 위치**를 나타내어 **원소를 식별하는 역할**
- **value**: **해당 원소가 속한 부모 정점**을 가리킴

#### 유니온(Union) 연산 동작 과정

1. 초기 상태: 모든 원소는 자기 자신을 부모로 가짐

```javascript
parent = ["A", "B", "C", "D", "E"];
```

- 각 원소는 독립적인 집합에 속해 있으며, 자기 자신이 부모이다.

2. B 정점이 A 정점에 속하도록 유니온 연산 수행

```javascript
parent = ["A", "A", "C", "D", "E"];
```

- B 정점의 부모 정점을 A 정점으로 변경 → B 정점이 A 정점의 집합에 포함됨

3. D 정점이 A 정점에 속하도록 유니온 연산 수행

```javascript
parent = ["A", "A", "C", "A", "E"];
```

- D 정점의 부모 정점을 A 정점으로 변경 → D 정점이 A 정점의 집합에 포함됨

4. E 정점이 C 정점에 속하도록 유니온 연산 수행

```javascript
parent = ["A", "A", "C", "D", "C"];
```

- E 정점의 부모 정점을 C 정점으로 변경 → E 정점이 C 정점의 집합에 포함됨

5. E 정점이 B 정점에 속하도록 유니온 연산 수행

```javascript
parent = ["A", "A", "A", "D", "E"];
```

- E 정점은 C 정점에 속해 있으므로, C 정점의 최상위 부모를 B 정점의 부모 정점으로 변경해야 함
- C 정점의 최상위 부모는 C 자체 → C 정점의 부모 정점을 B 정점의 부모 정점 A 정점으로 변경
- E 정점 역시 A 정점에 속하게 됨

6. 집합 정보 확인

- 현재 각 원소들의 부모를 살펴보면, 일부 원소는 아직 직접적인 루트 노드를 가리키지 않을 수도 있음
- 예를 들어, E 정점의 부모 정점이 C 정점으로 남아 있을 수 있음
- 이를 해결하기 위해, 경로 압축(Path Compression)을 적용하면 모든 원소가 직접 루트 노드를 가리키도록 최적화가 가능

<br />

### 파인드(Find) 연산: 특정 원소가 속한 집합의 대표(Root) 원소를 찾는 연산

![파인드 연산](/assets/images/algorithm/graph/union-find_find.webp)

#### 파인드(Find) 연산을 수행하는 과정 _(예시: E 정점의 최상위 원소를 찾기 위한 과정)_

1. E 정점의 부모를 확인하면 C 정점이므로, C 정점으로 이동한다.
1. C 정점의 부모를 확인하면 A 정점이므로, A 정점으로 이동한다.
1. A 정점의 부모를 확인하면 자기 자신을 가리키므로 탐색을 종료한다.
1. 따라서, E 정점이 속한 집합의 대표 원소는 A 정점이다.

#### 두 원소가 같은 집합에 속해 있는지 판단하는 방법

- **두 원소의 최상위 부모가 동일하면 같은 집합**에 속해있다는 의미
- 예를 들어, `find(E) === find(D)`가 참이면 E 정점과 D 정점은 같은 집합에 속해 있음

<br />

## 유니온-파인드(Union-Find) 알고리즘 문제점

![유니온-파인드 문제점](/assets/images/algorithm/graph/union-find_problem.webp)

- 유니온(Union) 연산이 비효율적으로 수행될 경우, 트리의 높이가 불필요하게 커질 수 있다.
- **편향된 트리(Skewed Tree)가 형성**되면, **파인드(Find) 연산의 시간 복잡도가 트리의 높이에 비례하여 $O(N)$**이 될 수 있다.

### 경로 압축(Path Compression)

![경로 압축 최적화](/assets/images/algorithm/graph/path_compression.webp)

- 경로 압축(Path Compression)은 유니온-파인드(Union-Find) 알고리즘의 대표적인 최적화 기법 중 하나이다.
- **파인드(Find) 연산을 수행하는 동안**, **경로에 있는 모든 원소들이 직접 최상위 부모를 가리키도록 변경하는 방식**이다.
  - 파인드(Find) 연산을 **재귀적으로 구현**했다면, **재귀 호출에서 되돌아오는 과정에서 각 원소의 부모를 최상위 부모로 변경**해준다.

#### 경로 압축(Path Compression) 효과

![경로 압축 효과](/assets/images/algorithm/graph/path_compression_works.webp)

- **경로 압축(Path Compression)을 수행**하면, **트리의 높이가 급격히 줄어들어 최적화가 이루어진다.**
- 이렇게 경로가 최적화하면, 이후의 **파인드(Find) 연산에서 거의 $O(1)$에 가까운 시간에 최상위 부모를 찾을 수 있다.**
- 최적화된 유니온-파인드(Union-Find)는 거의 **상수 시간($O(α(N)$))에 연산을 수행**할 수 있으며, 여기서 **$α(N)$(아커만 함수의 역함수)은 매우 느리게 증가하는 함수**이다.

#### 경로 압축(Path Compression)이 적용된 유니온-파인드(Union-Find) 알고리즘

```javascript
// 파인드(find) 연산: 특정 원소가 속한 집합의 대표 원소(Root Node)를 찾는 연산
function find(parent, x) {
  if (parent[x] === x) {
    return x;
  }

  // 경로 압축 최적화 -> 경로에 있는 모든 원소들이 직접 최상위 부모를 가리키도록 변경
  return (parent[x] = find(parent, parent[x]));
}
// 유니온(Union) 연산: 두 개의 서로서 집합을 하나의 집합으로 병합
function union(parent, a, b) {
  // 두 노드의 대표 노드를 가져온다.
  a = find(a);
  b = find(b);

  // 더 작은 값을 기준으로 서로서 집합을 하나의 집합으로 병합한다.
  if (a < b) {
    parent[b] = a;
  } else {
    parent[a] = b;
  }
}

// 두 개의 서로서 집합이 같은 집합인지 판단한다.
function compare(parent, a, b) {
  a = find(a);
  b = find(b);

  return a === b;
}
```
