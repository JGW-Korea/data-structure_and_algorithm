![그래프 배경 이미지](/assets/images/data_structor/graph/graph_thumbnail.webp)

그래프(Graph)란 **정점(Node)**과 **정점 사이를 연결하는 간선(Edge)**으로 이루어진 비선형 자료구조이다.

- 그래프는 정점 집합(Vertices)과 간선 집합(Edges)으로 표현할 수 있다.

#### 그래프(Graph) 특징

- 한 개의 정점(Graph)은 여러 개의 간선(Edge)을 가질 수 있다.

  - 선형 자료구조: 하나의 원소에서 앞, 뒤로 하나의 원소만 가질 수 있다.
  - 비선형 자료구조: 한 정점에서 여러 개의 간선을 통해 여러 개의 원소를 가질 수 있다.

- 그래프는 크게 방향 그래프(Directed Graph)와 무방향 그래프(Undirected Graph)로 나눌 수 있다.
- 정점 사이를 연결하는 간선(Edge)은 가중치를 가질 수 있다. (가중치: A 정점에서 B 정점까지의 거리)
- 그래프는 사이클(Cycle)이 발생할 수 있다. (그래프 탐색 시 사이클로 인해 무한루프에 빠지지 않도록 주의해야 함)
- 기존에 볼 수 있는 그래프인 두 정점 사이의 간선이 1개 이하이고, 루프가 존재하지 않는 그래프를 단순 그래프라고 부른다.

<br />

#### 사이클(Cycle)

![그래프 사이클](/assets/images/data_structor/graph/graph_cycle.webp)

- 사이클(Cycle)이란, 그래프의 정점과 간선의 부분 집합에서 순환이 되는 부분을 의미한다.
- 즉, 특정 정점에서 출발하여 다시 자기 자신으로 돌아올 수 있는 경로를 의미한다.

## 그래프(Graph) 종류

### 1. 방향 그래프 _Directed Graph_

![방향 그래프](/assets/images/data_structor/graph/directed_graph.webp)

- 방향 그래프(Directed Graph)란 간선(Edge)에 방향성이 존재하는 그래프로 해당 방향으로만 이동이 가능하다.
- 방향 그래프에서는 양방향으로 갈 수 있더라도 _(A, B)_, _(B, A)_ 는 다른 간선으로 취급된다,
- 실생활의 예시로 **일반 통행**을 생각하면 방향 그래프를 이해하기 쉽다.

### 2. 무방향 그래프 _Undirected Graph_

![무방향 그래프](/assets/images/data_structor/graph/undirected_graph.webp)

- 무방향 그래프(Undirected Graph)란 간선(Edge)에 방향성이 존재하지 않는 그래프로 이어진 정점들은 양방향으로 이동이 가능하다.
- 무방향 그래프는 _(A, B)_ 와 _(B, A)_ 는 같은 간선으로 취급된다.
- 실생활의 예시로 **양방향 통행 도로**를 생각하면 무방향 그래프를 이해하기 쉽다.

### 3. 연결 그래프 _Connected Graph_

![연결 그래프](/assets/images/data_structor/graph/connected_graph.webp)

- 연결 그래프(Connected Graph)란 특정 정점에서 모든 정점으로 이동 가능한 상태인 그래프를 의미한다. _(대표적으로 트리 자료구조가 이에 해당)_

### 4. 비연결 그래프 _Disconnected Graph_

![비연결 그래프](/assets/images/data_structor/graph/disconnected_graph.webp)

- 비연결 그래프(Disconnected Graph)란 특정 정점쌍 사이에 간선이 존재하지 않는 그래프를 의미한다.

### 5. 완전 그래프 _Completed Graph_

![완전 그래프](/assets/images/data_structor/graph/completed_graph.webp)

- 완전 그래프(Completed Graph)란 모든 정점끼리 간선으로 연결된 상태인 그래프를 의미한다.
- 완전 그래프의 한 개의 정점의 간선 수는 `전체 노드 - 1` 로 계산할 수 있다.
- 완전 그래프의 모든 정점의 간선 수는 `(전체 노드 - 1) * 전체 노드` 로 계산할 수 있다.

## 주의해야 할 그래프 유형

![주의해야 할 그래프 유형](/assets/images/data_structor/graph/waring_graphs.webp)

**1번 그래프**: 반드시 서로 다른 두 정점을 연결할 필요는 없다.
**2번 그래프**: 두 정점 사이의 간선의 개수는 반드시 1개 이하일 필요는 없다.

- 또한, A 정점과 같이 간선의 방향이 자신으로 돌아오는 간선이 있을 수도 있다. _(이런 간선은 루프(Loop) 간선이라고 부름)_

<br />

**코딩 테스트 그래프 유형 참고사항**

- 일반적으로 코딩 테스트 문제에서는 그래프의 조건을 엄격하게 지정하는 경우가 많다.
- 그러나, 1번 그래프처럼 그래프가 분리되어 있을수도 있으며, 2번 그래프처럼 두 정점 사이의 간선이 여러 개이거나, 루프(Loop)가 있는 형태일 수도 있다.
- 하지만, 코딩 테스트 문제를 해결하기 위해서는 어떤 그래프 형태를 가지더라도 올바른 코드를 작성할 수 있어야 한다.

## 그래프(Graph) 표현 방법

![그래프 표현 방법](/assets/images/data_structor/graph/graph_expression.webp)

프로그래밍 언어로 그래프를 표현할 수 있는 방법은 크게 **인접 행렬(Adjacency Matrix)**, **인접 리스트(Adjacency List)** 방식이 존재한다.

- 인접 행렬(Adjacency Matrix) : 2차원 배열을 이용하여 그래프를 표현한 방식
- 인접 리스트(Adjacency List) : 연결 리스트를 이용하여 그래프를 표현한 방식

## 그래프(Graph) 구현 방법

### 1. 인접 행렬(Adjacency Matrix) - 2차원 배열

![그래프 표현 방법 #1. 인접 행렬](/assets/images/data_structor/graph/adjacency_matrix_graph.webp)

> 사진의 그래프는 간선의 가중치 값을 가지지 않는 방향 그래프를 표현한 방법

- 인접 행렬(Adjacency Matrix)을 이용한 그래프는 연결된 두 정점을 1로, 연결되지 않은 두 정점을 0으로 표현할 수 있다.
- 간선 간의 가중치 값을 가질 경우 1과 0이 아닌 가중치 값을 할당해주면 된다. _(예시: `graph[from][to] = cost`)_

#### 방향 그래프 표현

```jsx
// #1. 2차원 배열을 통해 간선의 가중치가 없는 방향 그래프를 인접 행렬 방식으로 표현하는 방법
0: [0, 1, 0, 1, 0] // 0번 노드는 1번, 3번 노드로 이동이 가능하다.
1: [0, 0, 1, 0, 0] // 1번 노드는 2번 노드로 이동이 가능하다.
2: [1, 0, 0, 0, 1] // 2번 노드는 0번, 4번 노드로 이동이 가능하다.
3: [0, 0, 1, 0, 0] // 3번 노드는 2번 노드로 이동이 가능하다.
4: [1, 0, 0, 0, 0] // 4번 노드는 0번 노드로 이동이 가능하다.

// #2. 2차원 배열을 통해 간선의 가중치가 있는 방향 그래프를 인접 행렬 방식으로 표현하는 방법
0: [0, 3, 0, 7, 0] // 0번 노드는 1번(가중치 값: 3), 3번(가중치 값: 7) 노드로 이동이 가능하다.
1: [0, 0, 4, 0, 0] // 1번 노드는 2번(가중치 값: 4) 노드로 이동이 가능하다.
2: [2, 0, 0, 0, 9] // 2번 노드는 0번(가중치 값: 2), 4번(가중치 값: 9) 노드로 이동이 가능하다.
3: [0, 0, 5, 0, 0] // 3번 노드는 2번(가중치 값: 5) 노드로 이동이 가능하다.
4: [8, 0, 0, 0, 0] // 4번 노드는 0번(가중치 값: 8) 노드로 이동이 가능하다.
```

```jsx
// #1. 가중치가 없는 방향 그래프를 표현하는 코드
const graph = Array.from({ length: node }, () => new Array(node).fill(0));

for (const [from, to] of edge) {
  graph[from][to] = 1;
}

// #2. 가중치가 있는 방향 그래프를 표현하는 코드
const graph = Array.from({ length: node }, () => new Array(node).fill(0));

for (const [from, to, cost] of edge) {
  graph[from][to] = cost;
}
```

- 방향 그래프는 간선에 방향성이 존재하기 때문에 해당 방향으로만 이동이 가능하다. _(두 정점을 순회할 수 있는 간선은 다른 간선으로 취급)_

<br />

#### 무방향 그래프 표현

```jsx
// #1. 2차원 배열을 통해 간선의 가중치가 없는 무방향 그래프를 표현하는 방법
0: [0, 1, 1, 1, 1] // 0번 노드는 1, 2, 3, 4번 노드로 이동이 가능하다.
1: [1, 0, 1, 0, 0] // 1번 노드는 0, 2번 노드로 이동이 가능하다.
2: [1, 1, 0, 1, 1] // 2번 노드는 0, 1, 3, 4번 노드로 이동이 가능하다.
3: [1, 0, 1, 0, 0] // 3번 노드는 0, 2번 노드로 이동이 가능하다.
4: [1, 0, 1, 0, 0] // 4번 노드는 0, 2번 노드로 이동이 가능하다.

// #2. 2차원 배열을 통해 간선의 가중치가 있는 무방햫 그래프를 표현하는 방법
0: [0, 3, 5, 7, 2] // 0번 노드는 1(가중치 값: 3), 2(가중치 값: 5), 3(가중치 값: 7), 4(가중치 값: 2)번 노드로 이동이 가능하다.
1: [8, 0, 4, 0, 0] // 1번 노드는 0(가중치 값: 8), 2(가중치 값: 4)번 노드로 이동이 가능하다.
2: [2, 9, 0, 1, 9] // 2번 노드는 0(가중치 값: 2), 1(가중치 값: 9), 3(가중치 값: 1), 4(가중치 값: 9)번 노드로 이동이 가능하다.
3: [6, 0, 5, 0, 0] // 3번 노드는 0(가중치 값: 6), 2(가중치 값: 5)번 노드로 이동이 가능하다.
4: [8, 0, 4, 0, 0] // 4번 노드는 0(가중치 값: 8), 2(가중치 값: 4)번 노드로 이동이 가능하다.
```

```jsx
// #1. 가중치가 없는 무방향 그래프를 인접 행렬 방식으로 표현하는 코드
const graph = Array.from({ length: node }, () => new Array(node).fill(0));

for (const [from, to] of edge) {
  graph[from][to] = 1;
  graph[to][from] = 1;
}

// #2. 가중치가 있는 방향 그래프를 인접 행렬 방식으로 표현하는 코드
const graph = Array.from({ length: node }, () => new Array(node).fill(0));

for (const [from, to, cost] of edge) {
  graph[from][to] = cost;
  graph[to][from] = cost;
}
```

- 무방향 그래프는 간선에 방향성이 존재하지 않기 때문에 이어진 정점들을 양방향으로 이동 가능핟. _(두 정점을 순회할 수 있는 간선은 같은 간선으로 취급)_

<br />

#### 인접 행렬(Adjacency Matrix) 그래프 시간 복잡도와 공간 복잡도

- 시간 복잡도

  - 두 정점 연결 확인: $O(1)$
  - 특정 정점에 연결된 모든 정점 확인: $O(V)$

- 공간 복잡도
  - 인접 행렬을 통해 그래프 표현 방식은 2차원 배열을 사용하기 때문에 $O(V^{2})$ 공간 복잡도가 필요하다.

<br />

### 2. 인접 리스트(Adjacency List) - 연결 리스트

![그래프 표현 방법 #2. 인접 리스트](/assets/images/data_structor/graph/adjacency_list_graph.webp)

> 사진의 그래프는 간선의 가중치 값을 가지지 않는 방향 그래프를 표현한 방법
> JavaScript의 배열은 동적 크기를 가진 배열이기 때문에 연결 리스트가 아닌 배열로 표현이 가능

- 인접 리스트(Adjacency List)을 이용한 그래프는 V개의 리스트를 만들어 각 리스트에 자신과 연결된 정점(정점의 번호)을 넣어서 표현할 수 있다.
- 간선 간의 가중치 값을 가질 경우 `[to, cost]`와 같은 형태로 만들어주면 된다. _(예시: `graph[from].push([to, cost])`)_

#### 방향 그래프 표현

```jsx
// #1. 연결 리스트를 통해 간선의 가중치가 없는 방향 그래프를 인접 리스트 방식으로 표현하는 방법
0: [1, 3] // 0번 노드는 1, 3번 노드로 이동이 가능하다.
1: [2] // 1번 노드는 2번 노드로 이동이 가능하다.
2: [0, 4] // 2번 노드는 0, 4번 노드로 이동이 가능하다.
3: [2] // 3번 노드는 2번 노드로 이동이 가능하다.
4: [0] // 4번 노드는 0번 노드로 이동이 가능하다.

// #2. 연결 리스트를 통해 간선의 가중치가 있는 방향 그래프를 인접 리스트 방식으로 표현하는 방법
0: [[1, 3], [3, 7]], // 0번 노드는 1번(가중치 값: 3), 3번(가중치 값: 7) 노드로 이동이 가능하다.
1: [[2, 4]],         // 1번 노드는 2번(가중치 값: 4) 노드로 이동이 가능하다.
2: [[0, 2], [4, 9]], // 2번 노드는 0번(가중치 값: 2), 4번(가중치 값: 9) 노드로 이동이 가능하다.
3: [[2, 5]],         // 3번 노드는 2번(가중치 값: 5) 노드로 이동이 가능하다.
4: [[0, 8]],         // 4번 노드는 0번(가중치 값: 8) 노드로 이동이 가능하다.
```

```jsx
// #1. 가중치가 없는 방향 그래프를 표현하는 코드
const graph = Array.from({ length: node }, () => []);

for (const [from, to] of edge) {
  graph[from].push(to);
}

// #2. 가중치가 있는 방향 그래프를 표현하는 코드
const graph = Array.from({ length: node }, () => []);

for (const [from, to, cost] of edge) {
  graph[from].push([to, cost]);
}
```

- 방향 그래프는 간선에 방향성이 존재하기 때문에 해당 방향으로만 이동이 가능하다. _(두 정점을 순회할 수 있는 간선은 다른 간선으로 취급)_

<br />

#### 무방향 그래프 표현

```jsx
// #1. 연결 리스트를 통해 간선의 가중치가 없는 무방향 그래프를 인접 리스트 방식으로 표현하는 방법
0: [1, 2, 3, 4] // 0번 노드는 1, 2, 3, 4번 노드로 이동이 가능하다.
1: [0, 2] // 1번 노드는 0, 2번 노드로 이동이 가능하다.
2: [0, 1, 3, 4] // 2번 노드는 0, 1, 3, 4번 노드로 이동이 가능하다.
3: [0, 2] // 3번 노드는 0, 2번 노드로 이동이 가능하다.
4: [0, 2] // 4번 노드는 0, 2번 노드로 이동이 가능하다.

// #2. 2차원 배열을 통해 간선의 가중치가 있는 무방햫 그래프를 표현하는 방법
1: [[2, 4]],         // 1번 노드는 2번(가중치 값: 4) 노드로 이동이 가능하다.
2: [[0, 2], [4, 9]], // 2번 노드는 0번(가중치 값: 2), 4번(가중치 값: 9) 노드로 이동이 가능하다.
3: [[2, 5]],         // 3번 노드는 2번(가중치 값: 5) 노드로 이동이 가능하다.
4: [[0, 8]],         // 4번 노드는 0번(가중치 값: 8) 노드로 이동이 가능하다.

0: [[1, 3], [2, 5], [3, 7], [4, 2]], // 0번 노드는 1(가중치 값: 3), 2(가중치 값: 5), 3(가중치 값: 7), 4(가중치 값: 2)번 노드로 이동이 가능하다.
1: [[0, 8], [2, 4]],                 // 1번 노드는 0(가중치 값: 8), 2(가중치 값: 4)번 노드로 이동이 가능하다.
2: [[0, 2], [1, 9], [3, 1], [4, 9]], // 2번 노드는 0(가중치 값: 2), 1(가중치 값: 9), 3(가중치 값: 1), 4(가중치 값: 9)번 노드로 이동이 가능하다.
3: [[0, 6], [2, 5]],                 // 3번 노드는 0(가중치 값: 6), 2(가중치 값: 5)번 노드로 이동이 가능하다.
4: [[0, 8], [2, 4]],                 // 4번 노드는 0(가중치 값: 8), 2(가중치 값: 4)번 노드로 이동이 가능하다.
```

```jsx
// #1. 가중치가 없는 무방향 그래프를 인접 행렬 방식으로 표현하는 코드
const graph = Array.from({ length: node }, () => []);

for (const [from, to] of edge) {
  graph[from].push(to);
  graph[to].push(from);
}

// #2. 가중치가 있는 방향 그래프를 인접 행렬 방식으로 표현하는 코드
const graph = Array.from({ length: node }, () => []);

for (const [from, to, cost] of edge) {
  graph[from].push([to, cost]);
  graph[to].push([from, cost]);
}
```

- 무방향 그래프는 간선에 방향성이 존재하지 않기 때문에 이어진 정점들을 양방향으로 이동 가능핟. _(두 정점을 순회할 수 있는 간선은 같은 간선으로 취급)_

<br />

#### 인접 리스트(Adjacency List) 그래프 시간 복잡도와 공간 복잡도

- 시간 복잡도

  - 두 정점 연결 확인: $O(V)$
  - 특정 정점에 연결된 모든 정점 확인: $O(V)$

- 공간 복잡도
  - 인접 리스트를 이용한 그래프 표현은 $O(V + E)$ 공간 복잡도가 필요

## 각 그래프 표현 방법 시간 복잡도, 공간 복잡도

|                                   | 인접 행렬(Adjacency Matrix) | 인접 리스트(Adjacency List) |
| --------------------------------- | --------------------------- | --------------------------- |
| 공간 복잡도                       | $O(V^{2})$                  | $O(V + M)$                  |
| 두 정점 연결 확인                 | $O(1)$                      | $O(V)$                      |
| 특정 정점에 연결된 모든 정점 확인 | $O(V)$                      | $O(deg(V))$                 |

- $deg(V)$는 정점 집합인 V에 연결된 간선의 수를 의미한다. (즉, 정점의 집합 $V$는 차수를 의미)
